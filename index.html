<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Canvas - GPU-Powered 2D Graphics</title>
    <style>
        :root {
            /* Color Variables - Iron Man Theme */
            --primary-bg: linear-gradient(135deg, #330f0f 0%, #421a1a 100%);
            --hero-bg: linear-gradient(135deg, #8B0000 0%, #CD853F 100%);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.9);
            --text-muted: rgba(255, 215, 0, 0.8);
            --accent-primary: #DC143C;
            --accent-secondary: #B8860B;
            --accent-tertiary: #FFD700;
            --surface-primary: rgb(26, 15, 15);
            --surface-secondary: rgb(139, 0, 0);
            --surface-tertiary: rgba(205, 133, 63, 0.3);
            --border-primary: rgba(220, 20, 60, 0.3);
            --border-secondary: rgba(255, 215, 0, 0.3);
            --border-active: rgba(255, 215, 0, 0.8);
            --shadow-primary: rgba(0, 0, 0, 0.5);
            --shadow-accent: rgba(220, 20, 60, 0.4);
            --button-gradient: linear-gradient(45deg, #DC143C, #FFD700);
            --button-shadow: rgba(220, 20, 60, 0.4);
            --button-hover-shadow: rgba(255, 215, 0, 0.5);
            --playground-gradient: linear-gradient(45deg, #B8860B, #FFD700);
            --playground-shadow: rgba(184, 134, 11, 0.6);
            --grid-pattern-opacity: 0.2;
            --fps-counter-bg: rgba(0, 0, 0, 0.9);
            --fps-counter-color: #FFD700;
            --fps-counter-border: rgba(255, 215, 0, 0.4);
            --performance-warning-bg: rgba(255, 215, 0, 0.1);
            --performance-warning-border: rgba(255, 215, 0, 0.4);
            --performance-warning-color: #FFD700;
            --game-over-bg: rgba(0, 0, 0, 0.95);
            --game-over-border: #DC143C;
            --game-over-color: #DC143C;
            --code-bg: #1a1a1a;
            --code-border: rgba(220, 20, 60, 0.2);
            --code-highlight: #FFD700;
            --code-string: #DC143C;
            --code-comment: #B8860B;
            --key-bg: rgba(220, 20, 60, 0.2);
            --key-border: rgba(255, 215, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .hero {
            position: relative;
            background: var(--hero-bg);
            padding: 80px 20px;
            text-align: center;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: var(--grid-pattern-opacity);
        }

        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
        }

        .hero-title img {
            max-width: 50%;
            height: auto;
            display: block;
            margin: 0 auto 20px;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.6)) drop-shadow(0 2px 6px rgba(0, 0, 0, 0.3));
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #ffffff, #f5e6e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero .subtitle {
            font-size: 1.3rem;
            margin-bottom: 40px;
            opacity: 0.9;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            color: var(--text-secondary);
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 40px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }

        .feature {
            background: var(--surface-secondary);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--surface-tertiary);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .feature:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px var(--shadow-accent);
        }

        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .section {
            margin: 60px 0;
            padding: 40px;
            background: var(--surface-primary);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-primary);
            box-shadow: 0 8px 32px var(--shadow-primary);
        }

        .section h2 {
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-primary);
            position: relative;
        }

        .section h2::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--button-gradient);
            border-radius: 2px;
        }

        canvas {
            border: 2px solid var(--border-secondary);
            border-radius: 12px;
            display: block;
            margin: 30px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: #000;
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            outline: none;
            cursor: pointer;
            position: relative;
        }

        canvas:hover {
            box-shadow: 0 12px 40px var(--shadow-accent);
        }

        canvas:focus {
            border-color: var(--border-active);
            box-shadow: 0 12px 40px var(--button-hover-shadow);
        }

        canvas.game-active {
            border-color: var(--accent-secondary);
            box-shadow: 0 12px 40px rgba(139, 58, 58, 0.4);
        }

        .controls {
            text-align: center;
            margin: 30px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: var(--button-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px var(--button-shadow);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--button-hover-shadow);
        }

        button:active {
            transform: translateY(0);
        }

        .code-example {
            background: var(--code-bg);
            border: 1px solid var(--code-border);
            border-radius: 12px;
            padding: 25px;
            font-family: 'Courier New', 'Monaco', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 25px 0;
            position: relative;
        }

        .code-example::before {
            content: 'JavaScript';
            position: absolute;
            top: 8px;
            right: 15px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .highlight {
            color: var(--code-highlight);
        }

        .string {
            color: var(--code-string);
        }

        .comment {
            color: var(--code-comment);
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--fps-counter-bg);
            color: var(--fps-counter-color);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid var(--fps-counter-border);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(44, 24, 16, 0.4);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--border-primary);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-tertiary);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            color: var(--text-muted);
        }

        .game-controls {
            background: var(--surface-primary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid var(--border-primary);
        }

        .game-controls h4 {
            margin-bottom: 15px;
            text-align: center;
            color: var(--text-primary);
        }

        .control-row {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
        }

        .key {
            background: var(--key-bg);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid var(--key-border);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            max-width: 800px;
            margin: 20px auto;
            font-size: 18px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--game-over-bg);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 2px solid var(--game-over-border);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .game-over h3 {
            color: var(--game-over-color);
            margin-bottom: 20px;
            font-size: 2rem;
        }

        /* Toolbar Styles */
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(26, 15, 15, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-primary);
            padding: 10px 20px;
            z-index: 1000;
            display: flex;
            justify-content: center;
            gap: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .toolbar-button {
            padding: 8px 16px;
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .toolbar-button:hover {
            background: var(--surface-secondary);
            border-color: var(--border-active);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .toolbar-button.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Adjust body padding to account for fixed toolbar */
        body {
            padding-top: 60px;
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }

            .hero .subtitle {
                font-size: 1.1rem;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .features {
                grid-template-columns: 1fr;
            }

            .toolbar {
                flex-wrap: wrap;
                gap: 8px;
                padding: 8px 10px;
            }
            
            .toolbar-button {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            body {
                padding-top: 80px;
            }

            /* NEW MOBILE IMPROVEMENTS */
            .container {
                padding: 0 10px;
            }

            .section {
                margin: 30px 0;
                padding: 20px;
            }

            .hero {
                padding: 40px 10px;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .hero .subtitle {
                font-size: 1rem;
                padding: 0 10px;
            }

            .hero-title img {
                max-width: 80%;
            }

            /* Performance comparison - stack vertically on mobile */
            .section#performance > div[style*="grid-template-columns"] {
                display: block !important;
            }

            .section#performance > div[style*="grid-template-columns"] > div {
                margin-bottom: 30px;
            }

            .section#performance h3 {
                font-size: 1.2rem;
            }

            /* Canvas sizing for mobile */
            #basicCanvas {
                width: 100%;
                max-width: 100%;
                height: 250px;
            }

            #animationCanvas {
                width: 100%;
                max-width: 100%;
                height: 250px;
            }

            #stressCanvas, #canvas2dStress {
                width: 100%;
                max-width: 100%;
                height: 200px;
            }

            #gameCanvas {
                width: 100%;
                max-width: 100%;
                height: 300px;
            }

            /* Stats grid mobile layout */
            .stats-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .stat-card {
                padding: 15px 10px;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            .stat-label {
                font-size: 0.8rem;
            }

            /* Controls mobile layout */
            .controls {
                gap: 10px;
                margin: 20px 0;
            }

            button {
                padding: 10px 16px;
                font-size: 12px;
                min-width: 120px;
            }

            /* Game controls mobile */
            .game-controls {
                padding: 15px;
                margin: 15px 0;
            }

            .control-row {
                flex-direction: column;
                gap: 8px;
                margin: 8px 0;
                text-align: center;
            }

            .key {
                display: inline-block;
                margin: 2px;
            }

            /* Game info mobile */
            .game-info {
                flex-direction: column;
                gap: 10px;
                text-align: center;
                font-size: 16px;
                margin: 15px auto;
            }

            /* Features grid mobile */
            .features {
                gap: 15px;
                margin-top: 30px;
            }

            .feature {
                padding: 15px;
                text-align: center;
            }

            .feature h3 {
                font-size: 1.1rem;
                margin: 10px 0;
            }

            .feature p {
                font-size: 0.9rem;
            }

            /* Code examples mobile */
            .code-example {
                padding: 15px;
                font-size: 12px;
                overflow-x: auto;
            }

            .code-example::before {
                top: 5px;
                right: 10px;
                font-size: 10px;
            }

            /* Performance warning mobile */
            .performance-warning {
                padding: 12px;
                margin: 15px 0;
                font-size: 0.9rem;
            }

            /* Game over modal mobile */
            .game-over {
                padding: 30px 20px;
                margin: 0 10px;
                max-width: calc(100vw - 20px);
            }

            .game-over h3 {
                font-size: 1.5rem;
            }

            /* Toolbar improvements for mobile */
            .toolbar {
                position: fixed;
                bottom: 0;
                top: auto;
                padding: 10px;
                background: rgba(26, 15, 15, 0.98);
                border-top: 1px solid var(--border-primary);
                border-bottom: none;
                justify-content: space-around;
                overflow-x: auto;
                white-space: nowrap;
            }

            .toolbar-button {
                flex-shrink: 0;
                font-size: 10px;
                padding: 8px 6px;
                min-width: auto;
                text-align: center;
            }

            /* Remove top padding, add bottom padding for bottom toolbar */
            body {
                padding-top: 0;
                padding-bottom: 60px;
            }

            /* Playground link mobile */
            .playground-link {
                padding: 10px 20px;
                font-size: 14px;
                margin-top: 15px;
            }

            /* Responsive text sizes */
            .section h2 {
                font-size: 1.8rem;
                margin-bottom: 15px;
            }

            /* Touch-friendly focus styles */
            canvas:focus {
                outline: 2px solid var(--accent-tertiary);
                outline-offset: 2px;
            }
        }

        /* Additional mobile improvements for very small screens */
        @media (max-width: 480px) {
            .hero h1 {
                font-size: 1.8rem;
            }

            .hero .subtitle {
                font-size: 0.9rem;
            }

            .section {
                padding: 15px;
                margin: 20px 0;
            }

            .section h2 {
                font-size: 1.5rem;
            }

            button {
                min-width: 100px;
                padding: 8px 12px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .toolbar {
                padding: 8px 5px;
            }

            .toolbar-button {
                padding: 6px 4px;
                font-size: 9px;
            }

            #gameCanvas {
                height: 250px;
            }

            #stressCanvas, #canvas2dStress {
                height: 180px;
            }
        }

        .performance-warning {
            background: var(--performance-warning-bg);
            border: 1px solid var(--performance-warning-border);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: var(--performance-warning-color);
            text-align: center;
        }

        .playground-link {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 24px;
            background: var(--playground-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            text-decoration: none;
            box-shadow: 0 4px 15px var(--playground-shadow);
            transition: all 0.3s ease;
        }
    </style>
</head>

<body>
    <!-- Navigation Toolbar -->
    <div class="toolbar">
        <a href="#basic-shapes" class="toolbar-button" onclick="scrollToSection(event, 'basic-shapes')">üéØ Basic Shapes</a>
        <a href="#performance" class="toolbar-button" onclick="scrollToSection(event, 'performance')">üî• Performance</a>
        <a href="#animation" class="toolbar-button" onclick="scrollToSection(event, 'animation')">üîÑ Animation</a>
        <a href="#game" class="toolbar-button" onclick="scrollToSection(event, 'game')">üéÆ Game Demo</a>
        <a href="examples/playground.html" class="toolbar-button">üõ†Ô∏è Playground</a>
    </div>

    <div class="hero">
        <div class="hero-content">
            <div class="hero-title">
                <img id="bannerImage" src="banner.png" alt="WebGL Canvas" style="display: none;"
                    onerror="showFallbackTitle()">
                <h1 id="fallbackTitle" style="display: none;">üöÄ WebGL Canvas</h1>
            </div>
            <div class="subtitle">
                GPU-Powered 2D Graphics with HTML5 Canvas-like API<br>
                Easy to use ‚Ä¢ Blazingly Fast ‚Ä¢ Game Ready
            </div>

            <a href="examples/playground.html" class="playground-link">üõ†Ô∏è Open Playground</a>

            <div class="features">
                <div class="feature">
                    <div class="feature-icon">‚ö°</div>
                    <h3>GPU Accelerated</h3>
                    <p>Hardware-accelerated rendering for smooth 60fps graphics, leagues faster than traditional canvas</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé®</div>
                    <h3>Canvas-like API</h3>
                    <p>Familiar methods like fillRect(), drawCircle(), drawLine()</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üéÆ</div>
                    <h3>Game Ready</h3>
                    <p>Perfect for 2D games, visualizations, and interactive graphics</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé≠</div>
                    <h3>Custom Shaders</h3>
                    <p>Easy integration of custom fragment and vertex shaders</p>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="section" id="basic-shapes">
            <h2>üéØ Basic Shapes Demo</h2>
            <canvas id="basicCanvas" width="1000" height="500" tabindex="1"></canvas>
            <div class="controls">
                <button onclick="drawBasicShapes()">üé® Draw Basic Shapes</button>
                <button onclick="clearCanvas('basic')">üóëÔ∏è Clear</button>
            </div>
            <div class="code-example">
                <span class="comment">// Basic usage example</span><br>
                <span class="highlight">const</span> canvas = document.getElementById(<span
                    class="string">'myCanvas'</span>);<br>
                <span class="highlight">const</span> ctx = <span class="highlight">new</span> WebGLCanvas(canvas, { <br>
                &nbsp;&nbsp;enableFullscreen: <span class="highlight">true</span> <span class="comment">// Add
                    fullscreen button</span><br>
                });<br><br>

                <span class="comment">// Draw like HTML5 Canvas but with WebGL power!</span><br>
                ctx.fillStyle = <span class="string">'#ff6b6b'</span>;<br>
                ctx.fillRect(50, 50, 200, 100);<br><br>

                ctx.fillStyle = <span class="string">'#4ecdc4'</span>;<br>
                ctx.fillCircle(400, 100, 60);<br><br>

                ctx.strokeStyle = <span class="string">'#45b7d1'</span>;<br>
                ctx.lineWidth = 3;<br>
                ctx.drawLine(50, 200, 400, 200);
            </div>
        </div>
        <div class="section" id="performance">
            <h2>üî• Performance Comparison: WebGL vs Canvas2D</h2>
            <div class="performance-warning">
                ‚ö†Ô∏è This test renders thousands of objects to showcase performance differences. May be intensive on older
                devices.<br>
                üí° <em>Click the canvas to focus it and use arrow keys without scrolling the page!</em><br>
                üñ•Ô∏è <em>Look for the fullscreen button in the bottom-right corner of WebGL canvas!</em>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 20px 0;">
                <!-- WebGL Canvas Side -->
                <div>
                    <h3 style="text-align: center; margin-bottom: 15px; color: #00ff88;">üöÄ WebGL Canvas</h3>
                    <div style="position: relative; display: inline-block; width: 100%; text-align: center;">
                        <canvas id="stressCanvas" width="500" height="400"
                            style="position: relative; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 12px; display: block; margin: 0 auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); background: #000;"
                            tabindex="2"></canvas>
                        <!--div class="fps-counter" id="fpsCounter">FPS: --</div-->
                    </div>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; margin-top: 10px;">
                        <div class="stat-card">
                            <div class="stat-value" id="webglObjectCount">0</div>
                            <div class="stat-label">Objects</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="webglFpsDisplay">0</div>
                            <div class="stat-label">FPS</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="webglDrawCalls">0</div>
                            <div class="stat-label">Draw Calls</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="webglRenderTime">0ms</div>
                            <div class="stat-label">Render Time</div>
                        </div>
                    </div>
                    <!-- Global Controls -->
                    <div class="controls" style="justify-content: center; margin-top: 15px;">
                        <div style="opacity: 0.5; font-size: 12px; text-align: center;">
                            Use global controls below
                        </div>
                    </div>
                </div>

                <!-- Canvas2D Side -->
                <div>
                    <h3 style="text-align: center; margin-bottom: 15px; color: #ff6b6b;">üé® Canvas2D</h3>
                    <canvas id="canvas2dStress" width="500" height="400"
                        style="position: relative; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 12px; display: block; margin: 0 auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); background: #000;"
                        tabindex="5">
                    </canvas>
                    <div class="stats-grid" style="grid-template-columns: 1fr 1fr; margin-top: 10px;">
                        <div class="stat-card">
                            <div class="stat-value" id="canvas2dObjectCount">0</div>
                            <div class="stat-label">Objects</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="canvas2dFpsDisplay">0</div>
                            <div class="stat-label">FPS</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="canvas2dDrawCalls">0</div>
                            <div class="stat-label">Draw Calls</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="canvas2dRenderTime">0ms</div>
                            <div class="stat-label">Render Time</div>
                        </div>
                    </div>
                    <div class="controls" style="justify-content: center; margin-top: 15px;">
                        <div style="opacity: 0.5; font-size: 12px; text-align: center;">
                            Use global controls below
                        </div>
                    </div>
                </div>
            </div>

            <!-- Global Controls -->
            <div class="controls"
                style="margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                <button onclick="startWebGLStressTest()">üöÄ Start WebGL Test</button>
                <button onclick="startCanvas2DStressTest()">üé® Start Canvas2D Test</button>
                <button onclick="stopBothStressTests()">‚èπÔ∏è Stop All Tests</button>
                <button onclick="addObjectsToBoth()">‚ûï Add 500 Objects</button>
                <button onclick="removeObjectsFromBoth()">‚ûñ Remove 500 Objects</button>
                <button onclick="clearBothCanvases()">üóëÔ∏è Clear All</button>
            </div>

            <!-- Performance Summary -->
            <div id="performanceSummary"
                style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-top: 20px; text-align: center; display: none;">
                <h4>üìä Performance Summary</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <strong>WebGL Canvas:</strong><br>
                        <span id="webglSummary">-- FPS with -- objects</span>
                    </div>
                    <div>
                        <strong>Canvas2D:</strong><br>
                        <span id="canvas2dSummary">-- FPS with -- objects</span>
                    </div>
                </div>
                <div id="performanceWinner" style="margin-top: 15px; font-size: 1.2em; font-weight: bold;"></div>
            </div>
        </div>

        <div class="section" id="animation">
            <h2>üîÑ Animation & Transforms</h2>
            <canvas id="animationCanvas" width="1000" height="500" tabindex="3"></canvas>
            <div class="controls">
                <button onclick="startAnimation()">‚ñ∂Ô∏è Start Animation</button>
                <button onclick="stopAnimation()">‚è∏Ô∏è Stop Animation</button>
                <button onclick="clearCanvas('animation')">üóëÔ∏è Clear</button>
            </div>

            <div class="code-example">
                <span class="comment">// Animation with transforms</span><br>
                <span class="highlight">function</span> animate() {<br>
                &nbsp;&nbsp;ctx.clear();<br>
                &nbsp;&nbsp;ctx.save();<br><br>
                &nbsp;&nbsp;<span class="comment">// Rotate and animate</span><br>
                &nbsp;&nbsp;ctx.translate(400, 200);<br>
                &nbsp;&nbsp;ctx.rotate(time * 0.01);<br>
                &nbsp;&nbsp;ctx.fillStyle = <span class="string">'#ff9ff3'</span>;<br>
                &nbsp;&nbsp;ctx.fillRect(-50, -50, 100, 100);<br><br>
                &nbsp;&nbsp;ctx.restore();<br>
                &nbsp;&nbsp;requestAnimationFrame(animate);<br>
                }
            </div>
        </div>

        <div class="section" id="game">
            <h2>üéÆ Mini Game Demo</h2>
            <div class="game-info">
                <div>Score: <span id="gameScore">0</span></div>
                <div>Lives: <span id="gameLives">3</span></div>
                <div>Level: <span id="gameLevel">1</span></div>
            </div>
            <canvas id="gameCanvas" width="1000" height="600" tabindex="4"></canvas>
            <div class="game-controls">
                <h4>üéÆ Game Controls</h4>
                <div class="control-row">
                    <span class="key">W A S D</span> or <span class="key">Arrow Keys</span> - Move Ship
                </div>
                <div class="control-row">
                    <span class="key">SPACE</span> - Shoot ‚Ä¢ <span class="key">P</span> - Pause
                </div>
                <div class="control-row" style="margin-top: 15px; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
                    üí° <em>Click on any canvas to focus it and prevent page scrolling with arrow keys</em><br>
                    üñ•Ô∏è <em>Use the fullscreen button in the bottom-right corner for immersive gaming!</em>
                </div>
            </div>

            <div class="controls">
                <button onclick="startGame()">üöÄ Start Game</button>
                <button onclick="pauseGame()">‚è∏Ô∏è Pause</button>
                <button onclick="resetGame()">üîÑ Reset</button>
            </div>
        </div>
    </div>

    <div id="gameOver" class="game-over">
        <h3>Game Over!</h3>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">üéÆ Play Again</button>
    </div>
    <script src="src/webgl-canvas.js"></script>
    <script>
        // Global variables
        let basicCtx, animationCtx, stressCtx, gameCtx, canvas2dCtx;
        let animationId = null;
        let webglStressTestId = null;
        let canvas2dStressTestId = null;
        let gameAnimationId = null;

        // Performance tracking for WebGL
        let webglFrameCount = 0;
        let webglLastTime = performance.now();
        let webglFps = 0;
        let webglObjects = [];

        // Performance tracking for Canvas2D
        let canvas2dFrameCount = 0;
        let canvas2dLastTime = performance.now();
        let canvas2dFps = 0;
        let canvas2dObjects = [];

        // Focus management
        let focusedCanvas = null;
        let gameKeysEnabled = false;// Game state
        let gameRunning = false;
        let gamePaused = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameLevel = 1;
        let gameLastTime = 0;
        let asteroidSpawnTimer = 0;
        let keys = {};

        let currentActiveDemo = null; // Track which demo is currently running

        // Game objects
        let player = {
            x: 500,
            y: 520,
            width: 30,
            height: 30,
            speed: 400,
            color: '#00ff88'
        };

        let bullets = [];
        let asteroids = [];
        let particles = [];

        // Add scroll event listener
        window.addEventListener('scroll', updateToolbarOnScroll);
        
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function () {
            checkBannerImage(); // Check for banner image first
            initializeCanvases();
            setupCanvasFocus();
            setupGameInput();

            // Initial demos
            drawBasicShapes();
            updateGameUI();

            updateActiveToolbarButton('basic-shapes');
        });

        // Global demo control - NEW
        function stopAllDemos() {
            // Stop animation demo
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Stop WebGL stress test
            if (webglStressTestId) {
                cancelAnimationFrame(webglStressTestId);
                webglStressTestId = null;
            }

            // Stop Canvas2D stress test
            if (canvas2dStressTestId) {
                cancelAnimationFrame(canvas2dStressTestId);
                canvas2dStressTestId = null;
            }

            // Stop game
            if (gameAnimationId) {
                cancelAnimationFrame(gameAnimationId);
                gameAnimationId = null;
                gameRunning = false;
                gamePaused = false;
            }

            currentActiveDemo = null;
            console.log('All demos stopped');
        }

        function setActiveDemo(demoName) {
            if (currentActiveDemo === demoName) {
                return true; // Already active
            }

            stopAllDemos();
            currentActiveDemo = demoName;
            console.log(`Active demo set to: ${demoName}`);
            return true;
        }

        function initializeCanvases() {
            // Initialize canvases
            const basicCanvas = document.getElementById('basicCanvas');
            const animationCanvas = document.getElementById('animationCanvas');
            const stressCanvas = document.getElementById('stressCanvas');
            const gameCanvas = document.getElementById('gameCanvas');
            const canvas2dStressCanvas = document.getElementById('canvas2dStress');

            basicCtx = new WebGLCanvas(basicCanvas);
            animationCtx = new WebGLCanvas(animationCanvas);
            stressCtx = new WebGLCanvas(stressCanvas, { enableFullscreen: true });
            gameCtx = new WebGLCanvas(gameCanvas, { enableFullscreen: true });
            canvas2dCtx = canvas2dStressCanvas.getContext('2d');
        }

        // Canvas focus management
        function setupCanvasFocus() {
            const canvases = document.querySelectorAll('canvas');

            canvases.forEach(canvas => {
                // Add focus and blur event listeners
                canvas.addEventListener('focus', () => {
                    focusedCanvas = canvas.id;
                    gameKeysEnabled = (canvas.id === 'gameCanvas');

                    // Add visual indication for game canvas
                    if (canvas.id === 'gameCanvas' && gameRunning) {
                        canvas.classList.add('game-active');
                    }
                });

                canvas.addEventListener('blur', () => {
                    focusedCanvas = null;
                    gameKeysEnabled = false;
                    canvas.classList.remove('game-active');
                });

                // Click to focus
                canvas.addEventListener('click', () => {
                    canvas.focus();
                });

                // Prevent context menu on right click
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            });
        }

        // Basic shapes demo
        function drawBasicShapes() {
            // This is a one-time draw, so we don't need to manage it as an active demo
            if (!basicCtx) return;

            basicCtx.clear();

            // Background gradient effect
            for (let i = 0; i < 20; i++) {
                const alpha = (20 - i) / 20 * 0.1;
                basicCtx.fillStyle = `rgba(102, 126, 234, ${alpha})`;
                basicCtx.fillRect(0, i * 25, basicCtx.width, 25);
            }

            // Colorful rectangles
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            for (let i = 0; i < 7; i++) {
                basicCtx.fillStyle = colors[i];
                basicCtx.fillRect(50 + i * 130, 50, 100, 80);

                // Add subtle shadow effect
                basicCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                basicCtx.fillRect(55 + i * 130, 55, 100, 80);
                basicCtx.fillStyle = colors[i];
                basicCtx.fillRect(50 + i * 130, 50, 100, 80);
            }

            // Circles with different effects
            const circleColors = ['#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff6348'];
            for (let i = 0; i < 5; i++) {
                basicCtx.fillStyle = circleColors[i];
                basicCtx.fillCircle(150 + i * 170, 250, 40 + i * 5);

                // Inner circle for depth
                basicCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                basicCtx.fillCircle(150 + i * 170, 240, 15 + i * 2);
            }

            // Dynamic lines
            for (let i = 0; i < 10; i++) {
                basicCtx.strokeStyle = `hsl(${i * 36}, 70%, 60%)`;
                basicCtx.lineWidth = 3 + i * 0.5;
                basicCtx.drawLine(50 + i * 90, 350, 100 + i * 90, 400 + Math.sin(i) * 30);
            }

            // Complex pattern
            basicCtx.fillStyle = '#dda0dd';
            for (let i = 0; i < 15; i++) {
                basicCtx.fillCircle(80 + i * 60, 420, 15 - Math.abs(i - 7));
            }

            basicCtx.flush();
        }

        // Animation demo
        function startAnimation() {
            if (!animationCtx) return;

            if (!setActiveDemo('animation')) return;

            let startTime = Date.now();

            function animate() {
                if (currentActiveDemo !== 'animation') return; // Safety check

                const currentTime = Date.now();
                const elapsed = (currentTime - startTime) * 0.001;

                animationCtx.clear();

                // Animated background
                for (let i = 0; i < 10; i++) {
                    const alpha = Math.sin(elapsed + i * 0.5) * 0.1 + 0.1;
                    animationCtx.fillStyle = `rgba(${100 + i * 15}, ${150 + i * 10}, 255, ${alpha})`;
                    animationCtx.fillRect(i * 100, 0, 100, animationCtx.height);
                }

                // Rotating squares
                for (let i = 0; i < 5; i++) {
                    animationCtx.save();
                    animationCtx.translate(150 + i * 180, 150);
                    animationCtx.rotate(elapsed * (1 + i * 0.5));
                    animationCtx.fillStyle = `hsl(${elapsed * 50 + i * 60}, 70%, 60%)`;
                    animationCtx.fillRect(-30, -30, 60, 60);
                    animationCtx.restore();
                }

                // Bouncing circles
                for (let i = 0; i < 6; i++) {
                    const bounceY = 300 + Math.sin(elapsed * 3 + i * 0.8) * 80;
                    const size = 20 + Math.sin(elapsed * 2 + i) * 10;
                    animationCtx.fillStyle = `hsl(${elapsed * 30 + i * 45}, 80%, 70%)`;
                    animationCtx.fillCircle(100 + i * 150, bounceY, size);
                }

                // Wave lines
                animationCtx.strokeStyle = '#00ffff';
                animationCtx.lineWidth = 3;
                for (let x = 0; x < animationCtx.width; x += 5) {
                    const y1 = 400 + Math.sin(x * 0.02 + elapsed * 2) * 30;
                    const y2 = 400 + Math.sin((x + 5) * 0.02 + elapsed * 2) * 30;
                    animationCtx.drawLine(x, y1, x + 5, y2);
                }

                animationCtx.flush();

                animationId = requestAnimationFrame(animate);
            }

            animate();
        }

        function stopAnimation() {
            if (currentActiveDemo === 'animation') {
                stopAllDemos();
            }
        }

        // Stress test functions
        function startWebGLStressTest() {
            if (!setActiveDemo('webgl-stress')) return;

            // Stop Canvas2D if running
            stopCanvas2DStressTest();

            if (webglStressTestId) return;

            let lastFpsTime = performance.now();
            let frameCount = 0;

            function webglStressLoop() {
                if (currentActiveDemo !== 'webgl-stress') return; // Safety check

                const startTime = performance.now();

                stressCtx.clear();

                // Update objects
                for (let obj of webglObjects) {
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                    obj.rotation += obj.rotSpeed;

                    // Wrap around edges
                    if (obj.x < -obj.size) obj.x = stressCtx.width + obj.size;
                    if (obj.x > stressCtx.width + obj.size) obj.x = -obj.size;
                    if (obj.y < -obj.size) obj.y = stressCtx.height + obj.size;
                    if (obj.y > stressCtx.height + obj.size) obj.y = -obj.size;
                }

                // Render objects
                let drawCalls = 0;
                for (let obj of webglObjects) {
                    stressCtx.fillStyle = obj.color;

                    if (obj.type === 'circle') {
                        stressCtx.fillCircle(obj.x, obj.y, obj.size);
                    } else {
                        stressCtx.fillRect(obj.x - obj.size, obj.y - obj.size, obj.size * 2, obj.size * 2);
                    }
                    drawCalls++;
                }

                stressCtx.flush();

                const renderTime = performance.now() - startTime;

                // Calculate FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastFpsTime >= 1000) {
                    webglFps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                    frameCount = 0;
                    lastFpsTime = currentTime;

                    // Update stats
                    document.getElementById('webglFpsDisplay').textContent = webglFps;
                    document.getElementById('webglObjectCount').textContent = webglObjects.length;
                    document.getElementById('webglDrawCalls').textContent = drawCalls;
                    document.getElementById('webglRenderTime').textContent = renderTime.toFixed(2) + 'ms';

                    updatePerformanceSummary();
                }

                webglStressTestId = requestAnimationFrame(webglStressLoop);
            }

            webglStressLoop();
        }

        function stopWebGLStressTest() {
            if (webglStressTestId) {
                cancelAnimationFrame(webglStressTestId);
                webglStressTestId = null;
            }
        }

        function addWebGLObjects() {
            if (!stressCtx) return;

            for (let i = 0; i < 500; i++) {
                webglObjects.push({
                    x: Math.random() * (stressCtx.width - 20) + 10,
                    y: Math.random() * (stressCtx.height - 20) + 10,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    size: Math.random() * 8 + 3,
                    rotation: 0,
                    rotSpeed: (Math.random() - 0.5) * 0.1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    type: Math.random() > 0.5 ? 'circle' : 'rect'
                });
            }
        }

        function removeWebGLObjects() {
            webglObjects.splice(0, Math.min(500, webglObjects.length));
        }

        // Canvas2D Stress test functions
        function startCanvas2DStressTest() {
            if (!setActiveDemo('canvas2d-stress')) return;

            // Stop WebGL if running
            stopWebGLStressTest();

            if (canvas2dStressTestId) return;

            let lastFpsTime = performance.now();
            let frameCount = 0;
            const canvas = document.getElementById('canvas2dStress');

            function canvas2dStressLoop() {
                if (currentActiveDemo !== 'canvas2d-stress') return; // Safety check

                const startTime = performance.now();

                // Clear canvas
                canvas2dCtx.clearRect(0, 0, canvas.width, canvas.height);

                // Update objects
                for (let obj of canvas2dObjects) {
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                    obj.rotation += obj.rotSpeed;

                    // Wrap around edges
                    if (obj.x < -obj.size) obj.x = canvas.width + obj.size;
                    if (obj.x > canvas.width + obj.size) obj.x = -obj.size;
                    if (obj.y < -obj.size) obj.y = canvas.height + obj.size;
                    if (obj.y > canvas.height + obj.size) obj.y = -obj.size;
                }

                // Render objects
                let drawCalls = 0;
                for (let obj of canvas2dObjects) {
                    canvas2dCtx.fillStyle = obj.color;

                    if (obj.type === 'circle') {
                        canvas2dCtx.beginPath();
                        canvas2dCtx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
                        canvas2dCtx.fill();
                    } else {
                        canvas2dCtx.fillRect(obj.x - obj.size, obj.y - obj.size, obj.size * 2, obj.size * 2);
                    }
                    drawCalls++;
                }

                const renderTime = performance.now() - startTime;

                // Calculate FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastFpsTime >= 1000) {
                    canvas2dFps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                    frameCount = 0;
                    lastFpsTime = currentTime;

                    // Update stats
                    document.getElementById('canvas2dFpsDisplay').textContent = canvas2dFps;
                    document.getElementById('canvas2dObjectCount').textContent = canvas2dObjects.length;
                    document.getElementById('canvas2dDrawCalls').textContent = drawCalls;
                    document.getElementById('canvas2dRenderTime').textContent = renderTime.toFixed(2) + 'ms';

                    updatePerformanceSummary();
                }

                canvas2dStressTestId = requestAnimationFrame(canvas2dStressLoop);
            }

            canvas2dStressLoop();
        }

        function stopCanvas2DStressTest() {
            if (canvas2dStressTestId) {
                cancelAnimationFrame(canvas2dStressTestId);
                canvas2dStressTestId = null;
            }
        }

        function addCanvas2DObjects() {
            const canvas = document.getElementById('canvas2dStress');

            for (let i = 0; i < 500; i++) {
                canvas2dObjects.push({
                    x: Math.random() * (canvas.width - 20) + 10,
                    y: Math.random() * (canvas.height - 20) + 10,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    size: Math.random() * 8 + 3,
                    rotation: 0,
                    rotSpeed: (Math.random() - 0.5) * 0.1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    type: Math.random() > 0.5 ? 'circle' : 'rect'
                });
            }
        }

        function removeCanvas2DObjects() {
            canvas2dObjects.splice(0, Math.min(500, canvas2dObjects.length));
        }

        // Combined control functions
        function addObjectsToBoth() {
            addWebGLObjects();
            addCanvas2DObjects();

            // Update both object counts immediately
            document.getElementById('webglObjectCount').textContent = webglObjects.length;
            document.getElementById('canvas2dObjectCount').textContent = canvas2dObjects.length;
        }

        function removeObjectsFromBoth() {
            removeWebGLObjects();
            removeCanvas2DObjects();

            // Update both object counts immediately
            document.getElementById('webglObjectCount').textContent = webglObjects.length;
            document.getElementById('canvas2dObjectCount').textContent = canvas2dObjects.length;
        }

        function stopBothStressTests() {
            if (currentActiveDemo === 'webgl-stress' || currentActiveDemo === 'canvas2d-stress') {
                stopAllDemos();
            }
        }

        function clearBothCanvases() {
            clearCanvas('webgl');
            clearCanvas('canvas2d');
        }

        function updatePerformanceSummary() {
            const summary = document.getElementById('performanceSummary');
            const webglSummary = document.getElementById('webglSummary');
            const canvas2dSummary = document.getElementById('canvas2dSummary');
            const winner = document.getElementById('performanceWinner');

            if (webglObjects.length > 0 || canvas2dObjects.length > 0) {
                summary.style.display = 'block';

                // Show current status
                const webglStatus = webglStressTestId ? `üü¢ ${webglFps} FPS` : `‚≠ï Stopped`;
                const canvas2dStatus = canvas2dStressTestId ? `üü¢ ${canvas2dFps} FPS` : `‚≠ï Stopped`;

                webglSummary.innerHTML = `${webglStatus} with ${webglObjects.length} objects`;
                canvas2dSummary.innerHTML = `${canvas2dStatus} with ${canvas2dObjects.length} objects`;

                // Only compare when one is running
                if (webglStressTestId && !canvas2dStressTestId) {
                    winner.innerHTML = 'üöÄ WebGL Canvas is currently running';
                    winner.style.color = '#00ff88';
                } else if (canvas2dStressTestId && !webglStressTestId) {
                    winner.innerHTML = 'üé® Canvas2D is currently running';
                    winner.style.color = '#ff6b6b';
                } else if (!webglStressTestId && !canvas2dStressTestId) {
                    winner.innerHTML = '‚è∏Ô∏è Both tests are stopped - Start one to compare performance!';
                    winner.style.color = '#ffc107';
                } else {
                    winner.innerHTML = '';
                }
            } else {
                summary.style.display = 'none';
            }
        }

        // Game functions
        function setupGameInput() {
            document.addEventListener('keydown', (e) => {
                // Always track keys for game functionality
                keys[e.code] = true;

                // Prevent default behavior for game keys when any canvas is focused
                if (focusedCanvas && (
                    e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' ||
                    e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'ArrowLeft' || e.code === 'ArrowRight' ||
                    e.code === 'Space'
                )) {
                    e.preventDefault();
                }

                // Game-specific actions (only when game canvas is focused or game is running)
                if (gameKeysEnabled || gameRunning) {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        shoot();
                    }

                    if (e.code === 'KeyP') {
                        e.preventDefault();
                        pauseGame();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;

                // Prevent default behavior for game keys when any canvas is focused
                if (focusedCanvas && (
                    e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' ||
                    e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'ArrowLeft' || e.code === 'ArrowRight' ||
                    e.code === 'Space'
                )) {
                    e.preventDefault();
                }
            });
        }

        function startGame() {
            if (!setActiveDemo('game')) return;

            if (!gameRunning) {
                gameRunning = true;
                gamePaused = false;
                gameLoop();
            }
        }

        function pauseGame() {
            if (currentActiveDemo === 'game') {
                gamePaused = !gamePaused;
            }
        }

        function resetGame() {
            if (currentActiveDemo === 'game') {
                stopAllDemos();
            }

            gameRunning = false;
            gamePaused = false;
            gameScore = 0;
            gameLives = 3;
            gameLevel = 1;

            // Reset player to center bottom of canvas
            if (gameCtx) {
                player.x = gameCtx.width / 2 - player.width / 2;
                player.y = gameCtx.height - player.height - 20;
            } else {
                player.x = 500;
                player.y = 520;
            }

            bullets = [];
            asteroids = [];
            particles = [];

            updateGameUI();
            document.getElementById('gameOver').style.display = 'none';
        }

        function shoot() {
            if (!gameRunning || gamePaused) return;

            bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 12,
                speed: 600,
                color: '#ffff00'
            });
        }

        function spawnAsteroid() {
            asteroids.push({
                x: Math.random() * (gameCtx.width - 40),
                y: -40,
                width: 25 + Math.random() * 20,
                height: 25 + Math.random() * 20,
                speed: 80 + Math.random() * 100 + gameLevel * 15,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 3,
                color: '#ff6b6b'
            });
        }

        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 300,
                    vy: (Math.random() - 0.5) * 300,
                    life: 1.0,
                    decay: 0.02,
                    color: color,
                    size: 3 + Math.random() * 6
                });
            }
        }

        function updateGame(deltaTime) {
            if (!gameRunning || gamePaused) return;

            // Update player
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.y = Math.max(0, player.y - player.speed * deltaTime);
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.y = Math.min(gameCtx.height - player.height, player.y + player.speed * deltaTime);
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.x = Math.max(0, player.x - player.speed * deltaTime);
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.x = Math.min(gameCtx.width - player.width, player.x + player.speed * deltaTime);
            }

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= bullet.speed * deltaTime;

                if (bullet.y < -bullet.height) {
                    bullets.splice(i, 1);
                }
            }

            // Update asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                asteroid.y += asteroid.speed * deltaTime;
                asteroid.rotation += asteroid.rotationSpeed * deltaTime;

                if (asteroid.y > gameCtx.height) {
                    asteroids.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= particle.decay;

                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Check collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];

                    if (bullet.x < asteroid.x + asteroid.width &&
                        bullet.x + bullet.width > asteroid.x &&
                        bullet.y < asteroid.y + asteroid.height &&
                        bullet.y + bullet.height > asteroid.y) {

                        createParticles(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2, '#ffaa00');
                        bullets.splice(i, 1);
                        asteroids.splice(j, 1);
                        gameScore += 10;
                        break;
                    }
                }
            }

            // Player-asteroid collisions
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];

                if (player.x < asteroid.x + asteroid.width &&
                    player.x + player.width > asteroid.x &&
                    player.y < asteroid.y + asteroid.height &&
                    player.y + player.height > asteroid.y) {

                    createParticles(player.x + player.width / 2, player.y + player.height / 2, '#ff4444', 12);
                    asteroids.splice(i, 1);
                    gameLives--;

                    if (gameLives <= 0) {
                        gameOver();
                    }
                }
            }
            // Spawn asteroids with timer
            asteroidSpawnTimer += deltaTime;
            const spawnRate = Math.max(0.3, 1.5 - gameLevel * 0.1); // Faster spawning at higher levels

            if (asteroidSpawnTimer >= spawnRate) {
                spawnAsteroid();
                asteroidSpawnTimer = 0;
            }

            // Level progression
            if (gameScore > gameLevel * 150) {
                gameLevel++;
            }

            updateGameUI();
        }

        function renderGame() {
            gameCtx.clear();

            // Background stars
            gameCtx.fillStyle = '#ffffff';
            for (let i = 0; i < 100; i++) {
                const x = (i * 73) % gameCtx.width;
                const y = (i * 97) % gameCtx.height;
                const size = (i % 3) + 1;
                const alpha = 0.3 + (i % 3) * 0.2;
                gameCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                gameCtx.fillCircle(x, y, size);
            }
            // Draw player with glow effect
            gameCtx.fillStyle = 'rgba(0, 255, 136, 0.3)';
            gameCtx.fillCircle(player.x + player.width / 2, player.y + player.height / 2, player.width);

            // Player body
            gameCtx.fillStyle = player.color;
            gameCtx.fillRect(player.x, player.y, player.width, player.height);

            // Player details
            gameCtx.fillStyle = '#ffffff';
            gameCtx.fillRect(player.x + player.width / 2 - 8, player.y + player.height / 2 - 12, 16, 8);
            gameCtx.fillRect(player.x + player.width / 2 - 3, player.y + player.height / 2 - 20, 6, 8);

            // Draw bullets
            for (const bullet of bullets) {
                gameCtx.fillStyle = bullet.color;
                gameCtx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

                // Bullet trail
                gameCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                gameCtx.fillRect(bullet.x - 1, bullet.y + bullet.height, bullet.width + 2, 20);
            }
            // Draw asteroids
            for (const asteroid of asteroids) {
                const centerX = asteroid.x + asteroid.width / 2;
                const centerY = asteroid.y + asteroid.height / 2;

                // For now, draw without rotation to test positioning
                // Asteroid shadow
                gameCtx.fillStyle = 'rgba(255, 107, 107, 0.3)';
                gameCtx.fillRect(asteroid.x + 2, asteroid.y + 2, asteroid.width, asteroid.height);

                // Asteroid body
                gameCtx.fillStyle = asteroid.color;
                gameCtx.fillRect(asteroid.x, asteroid.y, asteroid.width, asteroid.height);

                // Asteroid detail
                gameCtx.fillStyle = '#cc5555';
                gameCtx.fillRect(asteroid.x + asteroid.width / 4, asteroid.y + asteroid.height / 4, asteroid.width / 2, asteroid.height / 2);
            }

            // Draw particles
            for (const particle of particles) {
                const alpha = Math.floor(particle.life * 255).toString(16).padStart(2, '0');
                gameCtx.fillStyle = particle.color + alpha;
                gameCtx.fillCircle(particle.x, particle.y, particle.size * particle.life);
            }

            gameCtx.flush();

            // Pause overlay
            if (gamePaused) {
                gameCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                gameCtx.fillRect(0, 0, gameCtx.width, gameCtx.height);
            }
        }

        function gameLoop(currentTime = 0) {
            if (currentActiveDemo !== 'game') return; // Safety check

            const deltaTime = (currentTime - gameLastTime) / 1000;
            gameLastTime = currentTime;

            updateGame(deltaTime);
            renderGame();

            if (gameRunning) {
                gameAnimationId = requestAnimationFrame(gameLoop);
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = gameScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLives').textContent = gameLives;
            document.getElementById('gameLevel').textContent = gameLevel;
        }

        

        function showFallbackTitle() {
            document.getElementById('bannerImage').style.display = 'none';
            document.getElementById('fallbackTitle').style.display = 'block';
        }

        function checkBannerImage() {
            const bannerImg = document.getElementById('bannerImage');
            const fallbackTitle = document.getElementById('fallbackTitle');

            // Try to load the banner image
            const testImg = new Image();
            testImg.onload = function () {
                bannerImg.style.display = 'block';
                fallbackTitle.style.display = 'none';
            };
            testImg.onerror = function () {
                bannerImg.style.display = 'none';
                fallbackTitle.style.display = 'block';
            };
            testImg.src = 'banner.png';
        }

        function scrollToSection(event, sectionId) {
            event.preventDefault();
            
            const section = document.getElementById(sectionId);
            if (section) {
                // Smooth scroll to section with offset for fixed toolbar
                const offsetTop = section.getBoundingClientRect().top + window.pageYOffset - 70;
                window.scrollTo({
                    top: offsetTop,
                    behavior: 'smooth'
                });
                
                // Update active toolbar button
                updateActiveToolbarButton(sectionId);
            }
        }

        function updateActiveToolbarButton(activeId) {
            // Remove active class from all toolbar buttons
            document.querySelectorAll('.toolbar-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to current section button
            const activeButton = document.querySelector(`[href="#${activeId}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        // Update active toolbar button based on scroll position
        function updateToolbarOnScroll() {
            const sections = ['basic-shapes', 'performance', 'animation', 'game'];
            const scrollPosition = window.scrollY + 100; // Offset for toolbar
            
            for (let i = sections.length - 1; i >= 0; i--) {
                const section = document.getElementById(sections[i]);
                if (section && section.offsetTop <= scrollPosition) {
                    updateActiveToolbarButton(sections[i]);
                    break;
                }
            }
        }

        function clearCanvas(type) {
            switch (type) {
                case 'basic':
                    if (basicCtx) basicCtx.clear();
                    break;
                case 'animation':
                    if (animationCtx) animationCtx.clear();
                    if (currentActiveDemo === 'animation') {
                        stopAllDemos();
                    }
                    break;
                case 'webgl':
                    if (stressCtx) stressCtx.clear();
                    if (currentActiveDemo === 'webgl-stress') {
                        stopAllDemos();
                    }
                    webglObjects = [];
                    document.getElementById('webglObjectCount').textContent = '0';
                    document.getElementById('webglFpsDisplay').textContent = '0';
                    document.getElementById('webglDrawCalls').textContent = '0';
                    document.getElementById('webglRenderTime').textContent = '0ms';
                    updatePerformanceSummary();
                    break;
                case 'canvas2d':
                    if (canvas2dCtx) {
                        const canvas = document.getElementById('canvas2dStress');
                        canvas2dCtx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    if (currentActiveDemo === 'canvas2d-stress') {
                        stopAllDemos();
                    }
                    canvas2dObjects = [];
                    document.getElementById('canvas2dObjectCount').textContent = '0';
                    document.getElementById('canvas2dFpsDisplay').textContent = '0';
                    document.getElementById('canvas2dDrawCalls').textContent = '0';
                    document.getElementById('canvas2dRenderTime').textContent = '0ms';
                    updatePerformanceSummary();
                    break;
            }
        }
    </script>
</body>

</html>