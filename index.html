<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Canvas - GPU-Powered 2D Graphics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .hero {
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 80px 20px;
            text-align: center;
            overflow: hidden;
        }
        
        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
        }
        
        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ffffff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .hero .subtitle {
            font-size: 1.3rem;
            margin-bottom: 40px;
            opacity: 0.9;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 40px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .feature {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .feature:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .section {
            margin: 60px 0;
            padding: 40px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .section h2 {
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
            color: #ffffff;
            position: relative;
        }
        
        .section h2::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 2px;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: block;
            margin: 30px auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: #000;
            transition: box-shadow 0.3s ease;
        }
        
        canvas:hover {
            box-shadow: 0 12px 40px rgba(102, 126, 234, 0.3);
        }
        
        .controls {
            text-align: center;
            margin: 30px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .code-example {
            background: #1a1a1a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 25px;
            font-family: 'Courier New', 'Monaco', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 25px 0;
            position: relative;
        }
        
        .code-example::before {
            content: 'JavaScript';
            position: absolute;
            top: 8px;
            right: 15px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .highlight {
            color: #569cd6;
        }
        
        .string {
            color: #ce9178;
        }
        
        .comment {
            color: #6a9955;
        }
        
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .game-controls {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-controls h4 {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .control-row {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
        }
        
        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            max-width: 800px;
            margin: 20px auto;
            font-size: 18px;
            font-weight: bold;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 2px solid #ff6b6b;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .game-over h3 {
            color: #ff6b6b;
            margin-bottom: 20px;
            font-size: 2rem;
        }
        
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .hero .subtitle {
                font-size: 1.1rem;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .features {
                grid-template-columns: 1fr;
            }
        }
        
        .performance-warning {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #ffc107;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="hero">
        <div class="hero-content">
            <h1>üöÄ WebGL Canvas</h1>
            <div class="subtitle">
                GPU-Powered 2D Graphics with HTML5 Canvas-like API<br>
                Easy to use ‚Ä¢ Blazingly Fast ‚Ä¢ Game Ready
            </div>
            
            <div class="features">
                <div class="feature">
                    <div class="feature-icon">‚ö°</div>
                    <h3>GPU Accelerated</h3>
                    <p>Hardware-accelerated rendering for smooth 60fps graphics</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé®</div>
                    <h3>Canvas-like API</h3>
                    <p>Familiar methods like fillRect(), drawCircle(), drawLine()</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üéÆ</div>
                    <h3>Game Ready</h3>
                    <p>Perfect for 2D games, visualizations, and interactive graphics</p>
                </div>
                <div class="feature">
                    <div class="feature-icon">üé≠</div>
                    <h3>Custom Shaders</h3>
                    <p>Easy integration of custom fragment and vertex shaders</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="section">
            <h2>üéØ Basic Shapes Demo</h2>
            <canvas id="basicCanvas" width="1000" height="500"></canvas>
            <div class="controls">
                <button onclick="drawBasicShapes()">üé® Draw Basic Shapes</button>
                <button onclick="clearCanvas('basic')">üóëÔ∏è Clear</button>
            </div>
            
            <div class="code-example">
                <span class="comment">// Basic usage example</span><br>
<span class="highlight">const</span> canvas = document.getElementById(<span class="string">'myCanvas'</span>);<br>
<span class="highlight">const</span> ctx = <span class="highlight">new</span> WebGLCanvas(canvas);<br><br>

<span class="comment">// Draw like HTML5 Canvas but with WebGL power!</span><br>
ctx.fillStyle = <span class="string">'#ff6b6b'</span>;<br>
ctx.fillRect(50, 50, 200, 100);<br><br>

ctx.fillStyle = <span class="string">'#4ecdc4'</span>;<br>
ctx.fillCircle(400, 100, 60);<br><br>

ctx.strokeStyle = <span class="string">'#45b7d1'</span>;<br>
ctx.lineWidth = 3;<br>
ctx.drawLine(50, 200, 400, 200);
            </div>
        </div>
        
        <div class="section">
            <h2>üî• Performance Stress Test</h2>
            <div class="performance-warning">
                ‚ö†Ô∏è This test renders thousands of objects to showcase WebGL performance. May be intensive on older devices.
            </div>
            <canvas id="stressCanvas" width="1000" height="600" style="position: relative;">
                <div class="fps-counter" id="fpsCounter">FPS: --</div>
            </canvas>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="objectCount">0</div>
                    <div class="stat-label">Objects Rendered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="fpsDisplay">0</div>
                    <div class="stat-label">Frames Per Second</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="drawCalls">0</div>
                    <div class="stat-label">Draw Calls/Frame</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="renderTime">0ms</div>
                    <div class="stat-label">Render Time</div>
                </div>
            </div>
            <div class="controls">
                <button onclick="startStressTest()">üöÄ Start Stress Test</button>
                <button onclick="stopStressTest()">‚èπÔ∏è Stop Test</button>
                <button onclick="addObjects()">‚ûï Add 500 Objects</button>
                <button onclick="removeObjects()">‚ûñ Remove 500 Objects</button>
                <button onclick="clearCanvas('stress')">üóëÔ∏è Clear</button>
            </div>
        </div>
        
        <div class="section">
            <h2>üîÑ Animation & Transforms</h2>
            <canvas id="animationCanvas" width="1000" height="500"></canvas>
            <div class="controls">
                <button onclick="startAnimation()">‚ñ∂Ô∏è Start Animation</button>
                <button onclick="stopAnimation()">‚è∏Ô∏è Stop Animation</button>
                <button onclick="clearCanvas('animation')">üóëÔ∏è Clear</button>
            </div>
            
            <div class="code-example">
                <span class="comment">// Animation with transforms</span><br>
<span class="highlight">function</span> animate() {<br>
&nbsp;&nbsp;ctx.clear();<br>
&nbsp;&nbsp;ctx.save();<br><br>
&nbsp;&nbsp;<span class="comment">// Rotate and animate</span><br>
&nbsp;&nbsp;ctx.translate(400, 200);<br>
&nbsp;&nbsp;ctx.rotate(time * 0.01);<br>
&nbsp;&nbsp;ctx.fillStyle = <span class="string">'#ff9ff3'</span>;<br>
&nbsp;&nbsp;ctx.fillRect(-50, -50, 100, 100);<br><br>
&nbsp;&nbsp;ctx.restore();<br>
&nbsp;&nbsp;requestAnimationFrame(animate);<br>
}
            </div>
        </div>
        
        <div class="section">
            <h2>üéÆ Mini Game Demo</h2>
            <div class="game-info">
                <div>Score: <span id="gameScore">0</span></div>
                <div>Lives: <span id="gameLives">3</span></div>
                <div>Level: <span id="gameLevel">1</span></div>
            </div>
            <canvas id="gameCanvas" width="1000" height="600"></canvas>
            
            <div class="game-controls">
                <h4>üéÆ Game Controls</h4>
                <div class="control-row">
                    <span class="key">W A S D</span> or <span class="key">Arrow Keys</span> - Move Ship
                </div>
                <div class="control-row">
                    <span class="key">SPACE</span> - Shoot ‚Ä¢ <span class="key">P</span> - Pause
                </div>
            </div>
            
            <div class="controls">
                <button onclick="startGame()">üöÄ Start Game</button>
                <button onclick="pauseGame()">‚è∏Ô∏è Pause</button>
                <button onclick="resetGame()">üîÑ Reset</button>
            </div>
        </div>
    </div>
    
    <div id="gameOver" class="game-over">
        <h3>Game Over!</h3>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">üéÆ Play Again</button>
    </div><script src="src/webgl-canvas.js"></script>
    <script>
        // Global variables
        let basicCtx, animationCtx, stressCtx, gameCtx;
        let animationId = null;
        let stressTestId = null;
        let gameAnimationId = null;
        
        // Performance tracking
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        let objectCount = 0;
        let stressObjects = [];        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameLevel = 1;
        let gameLastTime = 0;
        let asteroidSpawnTimer = 0;
        let keys = {};
        
        // Game objects
        let player = {
            x: 500,
            y: 520,
            width: 30,
            height: 30,
            speed: 400,
            color: '#00ff88'
        };
        
        let bullets = [];
        let asteroids = [];
        let particles = [];
        
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvases();
            setupGameInput();
            
            // Initial demos
            drawBasicShapes();
            updateGameUI();
        });
        
        function initializeCanvases() {
            // Initialize canvases
            const basicCanvas = document.getElementById('basicCanvas');
            const animationCanvas = document.getElementById('animationCanvas');
            const stressCanvas = document.getElementById('stressCanvas');
            const gameCanvas = document.getElementById('gameCanvas');
            
            basicCtx = new WebGLCanvas(basicCanvas);
            animationCtx = new WebGLCanvas(animationCanvas);
            stressCtx = new WebGLCanvas(stressCanvas);
            gameCtx = new WebGLCanvas(gameCanvas);
        }
        
        // Basic shapes demo
        function drawBasicShapes() {
            if (!basicCtx) return;
            
            basicCtx.clear();
            
            // Background gradient effect
            for (let i = 0; i < 20; i++) {
                const alpha = (20 - i) / 20 * 0.1;
                basicCtx.fillStyle = `rgba(102, 126, 234, ${alpha})`;
                basicCtx.fillRect(0, i * 25, basicCtx.width, 25);
            }
            
            // Colorful rectangles
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            for (let i = 0; i < 7; i++) {
                basicCtx.fillStyle = colors[i];
                basicCtx.fillRect(50 + i * 130, 50, 100, 80);
                
                // Add subtle shadow effect
                basicCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                basicCtx.fillRect(55 + i * 130, 55, 100, 80);
                basicCtx.fillStyle = colors[i];
                basicCtx.fillRect(50 + i * 130, 50, 100, 80);
            }
            
            // Circles with different effects
            const circleColors = ['#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff6348'];
            for (let i = 0; i < 5; i++) {
                basicCtx.fillStyle = circleColors[i];
                basicCtx.fillCircle(150 + i * 170, 250, 40 + i * 5);
                
                // Inner circle for depth
                basicCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                basicCtx.fillCircle(150 + i * 170, 240, 15 + i * 2);
            }
            
            // Dynamic lines
            for (let i = 0; i < 10; i++) {
                basicCtx.strokeStyle = `hsl(${i * 36}, 70%, 60%)`;
                basicCtx.lineWidth = 3 + i * 0.5;
                basicCtx.drawLine(50 + i * 90, 350, 100 + i * 90, 400 + Math.sin(i) * 30);
            }
            
            // Complex pattern
            basicCtx.fillStyle = '#dda0dd';
            for (let i = 0; i < 15; i++) {
                basicCtx.fillCircle(80 + i * 60, 420, 15 - Math.abs(i - 7));
            }
        }
        
        // Animation demo
        function startAnimation() {
            if (!animationCtx) return;
            
            let startTime = Date.now();
            
            function animate() {
                const currentTime = Date.now();
                const elapsed = (currentTime - startTime) * 0.001;
                
                animationCtx.clear();
                
                // Animated background
                for (let i = 0; i < 10; i++) {
                    const alpha = Math.sin(elapsed + i * 0.5) * 0.1 + 0.1;
                    animationCtx.fillStyle = `rgba(${100 + i * 15}, ${150 + i * 10}, 255, ${alpha})`;
                    animationCtx.fillRect(i * 100, 0, 100, animationCtx.height);
                }
                
                // Rotating squares
                for (let i = 0; i < 5; i++) {
                    animationCtx.save();
                    animationCtx.translate(150 + i * 180, 150);
                    animationCtx.rotate(elapsed * (1 + i * 0.5));
                    animationCtx.fillStyle = `hsl(${elapsed * 50 + i * 60}, 70%, 60%)`;
                    animationCtx.fillRect(-30, -30, 60, 60);
                    animationCtx.restore();
                }
                
                // Bouncing circles
                for (let i = 0; i < 6; i++) {
                    const bounceY = 300 + Math.sin(elapsed * 3 + i * 0.8) * 80;
                    const size = 20 + Math.sin(elapsed * 2 + i) * 10;
                    animationCtx.fillStyle = `hsl(${elapsed * 30 + i * 45}, 80%, 70%)`;
                    animationCtx.fillCircle(100 + i * 150, bounceY, size);
                }
                
                // Wave lines
                animationCtx.strokeStyle = '#00ffff';
                animationCtx.lineWidth = 3;
                for (let x = 0; x < animationCtx.width; x += 5) {
                    const y1 = 400 + Math.sin(x * 0.02 + elapsed * 2) * 30;
                    const y2 = 400 + Math.sin((x + 5) * 0.02 + elapsed * 2) * 30;
                    animationCtx.drawLine(x, y1, x + 5, y2);
                }
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // Stress test functions
        function startStressTest() {
            if (stressTestId) return;
            
            let lastFpsTime = performance.now();
            let frameCount = 0;
            
            function stressLoop() {
                const startTime = performance.now();
                
                stressCtx.clear();
                  // Update objects
                for (let obj of stressObjects) {
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                    obj.rotation += obj.rotSpeed;
                    
                    // Wrap around edges instead of bouncing
                    if (obj.x < -obj.size) obj.x = stressCtx.width + obj.size;
                    if (obj.x > stressCtx.width + obj.size) obj.x = -obj.size;
                    if (obj.y < -obj.size) obj.y = stressCtx.height + obj.size;
                    if (obj.y > stressCtx.height + obj.size) obj.y = -obj.size;
                }                // Render objects
                let drawCalls = 0;
                for (let obj of stressObjects) {
                    stressCtx.fillStyle = obj.color;
                    
                    if (obj.type === 'circle') {
                        stressCtx.fillCircle(obj.x, obj.y, obj.size);
                    } else {
                        stressCtx.fillRect(obj.x - obj.size, obj.y - obj.size, obj.size * 2, obj.size * 2);
                    }
                    drawCalls++;
                }
                
                const renderTime = performance.now() - startTime;
                
                // Calculate FPS
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastFpsTime >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastFpsTime));
                    frameCount = 0;
                    lastFpsTime = currentTime;
                    
                    // Update stats
                    document.getElementById('fpsDisplay').textContent = fps;
                    document.getElementById('objectCount').textContent = stressObjects.length;
                    document.getElementById('drawCalls').textContent = drawCalls;
                    document.getElementById('renderTime').textContent = renderTime.toFixed(2) + 'ms';
                }
                
                stressTestId = requestAnimationFrame(stressLoop);
            }
            
            stressLoop();
        }
        
        function stopStressTest() {
            if (stressTestId) {
                cancelAnimationFrame(stressTestId);
                stressTestId = null;
            }
        }
          function addObjects() {
            if (!stressCtx) return;
            
            for (let i = 0; i < 500; i++) {
                stressObjects.push({
                    x: Math.random() * (stressCtx.width - 20) + 10,
                    y: Math.random() * (stressCtx.height - 20) + 10,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    size: Math.random() * 8 + 3,
                    rotation: 0,
                    rotSpeed: (Math.random() - 0.5) * 0.1,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    type: Math.random() > 0.5 ? 'circle' : 'rect'
                });
            }
        }
        
        function removeObjects() {
            stressObjects.splice(0, Math.min(500, stressObjects.length));
        }
        
        // Game functions
        function setupGameInput() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    shoot();
                }
                
                if (e.code === 'KeyP') {
                    pauseGame();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
        }
        
        function startGame() {
            if (!gameRunning) {
                gameRunning = true;
                gamePaused = false;
                gameLoop();
            }
        }
        
        function pauseGame() {
            gamePaused = !gamePaused;
        }
          function resetGame() {
            gameRunning = false;
            gamePaused = false;
            gameScore = 0;
            gameLives = 3;
            gameLevel = 1;
            
            // Reset player to center bottom of canvas
            if (gameCtx) {
                player.x = gameCtx.width / 2 - player.width / 2;
                player.y = gameCtx.height - player.height - 20;
            } else {
                player.x = 500;
                player.y = 520;
            }
            
            bullets = [];
            asteroids = [];
            particles = [];
            
            updateGameUI();
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function shoot() {
            if (!gameRunning || gamePaused) return;
            
            bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 12,
                speed: 600,
                color: '#ffff00'
            });
        }
        
        function spawnAsteroid() {
            asteroids.push({
                x: Math.random() * (gameCtx.width - 40),
                y: -40,
                width: 25 + Math.random() * 20,
                height: 25 + Math.random() * 20,
                speed: 80 + Math.random() * 100 + gameLevel * 15,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 3,
                color: '#ff6b6b'
            });
        }
        
        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 300,
                    vy: (Math.random() - 0.5) * 300,
                    life: 1.0,
                    decay: 0.02,
                    color: color,
                    size: 3 + Math.random() * 6
                });
            }
        }
        
        function updateGame(deltaTime) {
            if (!gameRunning || gamePaused) return;
            
            // Update player
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.y = Math.max(0, player.y - player.speed * deltaTime);
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.y = Math.min(gameCtx.height - player.height, player.y + player.speed * deltaTime);
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.x = Math.max(0, player.x - player.speed * deltaTime);
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.x = Math.min(gameCtx.width - player.width, player.x + player.speed * deltaTime);
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= bullet.speed * deltaTime;
                
                if (bullet.y < -bullet.height) {
                    bullets.splice(i, 1);
                }
            }
            
            // Update asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                asteroid.y += asteroid.speed * deltaTime;
                asteroid.rotation += asteroid.rotationSpeed * deltaTime;
                
                if (asteroid.y > gameCtx.height) {
                    asteroids.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Check collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];
                    
                    if (bullet.x < asteroid.x + asteroid.width &&
                        bullet.x + bullet.width > asteroid.x &&
                        bullet.y < asteroid.y + asteroid.height &&
                        bullet.y + bullet.height > asteroid.y) {
                        
                        createParticles(asteroid.x + asteroid.width/2, asteroid.y + asteroid.height/2, '#ffaa00');
                        bullets.splice(i, 1);
                        asteroids.splice(j, 1);
                        gameScore += 10;
                        break;
                    }
                }
            }
            
            // Player-asteroid collisions
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                
                if (player.x < asteroid.x + asteroid.width &&
                    player.x + player.width > asteroid.x &&
                    player.y < asteroid.y + asteroid.height &&
                    player.y + player.height > asteroid.y) {
                    
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#ff4444', 12);
                    asteroids.splice(i, 1);
                    gameLives--;
                    
                    if (gameLives <= 0) {
                        gameOver();
                    }
                }
            }
              // Spawn asteroids with timer
            asteroidSpawnTimer += deltaTime;
            const spawnRate = Math.max(0.3, 1.5 - gameLevel * 0.1); // Faster spawning at higher levels
            
            if (asteroidSpawnTimer >= spawnRate) {
                spawnAsteroid();
                asteroidSpawnTimer = 0;
            }
            
            // Level progression
            if (gameScore > gameLevel * 150) {
                gameLevel++;
            }
            
            updateGameUI();
        }
        
        function renderGame() {
            gameCtx.clear();
            
            // Background stars
            gameCtx.fillStyle = '#ffffff';
            for (let i = 0; i < 100; i++) {
                const x = (i * 73) % gameCtx.width;
                const y = (i * 97) % gameCtx.height;
                const size = (i % 3) + 1;
                const alpha = 0.3 + (i % 3) * 0.2;
                gameCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                gameCtx.fillCircle(x, y, size);
            }
              // Draw player with glow effect
            gameCtx.fillStyle = 'rgba(0, 255, 136, 0.3)';
            gameCtx.fillCircle(player.x + player.width/2, player.y + player.height/2, player.width);
            
            // Player body
            gameCtx.fillStyle = player.color;
            gameCtx.fillRect(player.x, player.y, player.width, player.height);
            
            // Player details
            gameCtx.fillStyle = '#ffffff';
            gameCtx.fillRect(player.x + player.width/2 - 8, player.y + player.height/2 - 12, 16, 8);
            gameCtx.fillRect(player.x + player.width/2 - 3, player.y + player.height/2 - 20, 6, 8);
            
            // Draw bullets
            for (const bullet of bullets) {
                gameCtx.fillStyle = bullet.color;
                gameCtx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                // Bullet trail
                gameCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                gameCtx.fillRect(bullet.x - 1, bullet.y + bullet.height, bullet.width + 2, 20);
            }
              // Draw asteroids
            for (const asteroid of asteroids) {
                const centerX = asteroid.x + asteroid.width/2;
                const centerY = asteroid.y + asteroid.height/2;
                
                // For now, draw without rotation to test positioning
                // Asteroid shadow
                gameCtx.fillStyle = 'rgba(255, 107, 107, 0.3)';
                gameCtx.fillRect(asteroid.x + 2, asteroid.y + 2, asteroid.width, asteroid.height);
                
                // Asteroid body
                gameCtx.fillStyle = asteroid.color;
                gameCtx.fillRect(asteroid.x, asteroid.y, asteroid.width, asteroid.height);
                
                // Asteroid detail
                gameCtx.fillStyle = '#cc5555';
                gameCtx.fillRect(asteroid.x + asteroid.width/4, asteroid.y + asteroid.height/4, asteroid.width/2, asteroid.height/2);
            }
            
            // Draw particles
            for (const particle of particles) {
                const alpha = Math.floor(particle.life * 255).toString(16).padStart(2, '0');
                gameCtx.fillStyle = particle.color + alpha;
                gameCtx.fillCircle(particle.x, particle.y, particle.size * particle.life);
            }
            
            // Pause overlay
            if (gamePaused) {
                gameCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                gameCtx.fillRect(0, 0, gameCtx.width, gameCtx.height);
            }
        }
        
        function gameLoop(currentTime = 0) {
            const deltaTime = (currentTime - gameLastTime) / 1000;
            gameLastTime = currentTime;
            
            updateGame(deltaTime);
            renderGame();
            
            if (gameRunning) {
                gameAnimationId = requestAnimationFrame(gameLoop);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = gameScore;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLives').textContent = gameLives;
            document.getElementById('gameLevel').textContent = gameLevel;
        }
        
        function clearCanvas(type) {
            switch(type) {
                case 'basic':
                    if (basicCtx) basicCtx.clear();
                    break;
                case 'animation':
                    if (animationCtx) animationCtx.clear();
                    stopAnimation();
                    break;
                case 'stress':
                    if (stressCtx) stressCtx.clear();
                    stopStressTest();
                    stressObjects = [];
                    document.getElementById('objectCount').textContent = '0';
                    document.getElementById('fpsDisplay').textContent = '0';
                    document.getElementById('drawCalls').textContent = '0';
                    document.getElementById('renderTime').textContent = '0ms';
                    break;
            }
        }
    </script>
</body>
</html>
